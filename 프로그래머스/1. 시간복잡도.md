>  알고리즘이 문제를 해결하는 데 걸리는 시간의 증가율을 나타내는 개념
## 1.1 입력 데이터 개수별 사용가능한 시간 복잡도 알고리즘
- 1초에 1억을 넘기지 않아야 함
    - n = 10만 -> O(n2) -> 10억이니까 안됨.
    - 10억을 넘긴다면 무조건 다시 로직 짜야됨.
- 1초에 1억을 넘긴다면 다씨 로직을 짜야함.
> 시간 복잡도를 이용하여 효율성이 검증되면 그 이후에 코드를 작성해야 함.
![[Pasted image 20250823180332.png]]

## 1.2 시간복잡도 계산하기
- 가장 기본적인 방법은 반복 횟수를 세는 것
    - 반복문이 어떤 값에 비레해서 반복하는지 따져 보면 시간 복잡도를 계산 가능

### 1.2.1 어림짐작 해보기

(1) 시간 복잡도는 실행 시간이 어떤 요인으로 결정되는지 나타내는 수식
- 곱해지 거나 더해지는 상수 부분은 나태내지 않음

(2) 배열을 M번 반복해야 하다면 M은 무시해서는 안됨
- 길이를 n인 배열을 M번 반복해야 하므로 `O(NM)`이 되며, N과 M의 최댓값을 구하여 시간 복잡도에 대입해야 함.

(3) 길이 N짜리 배열을 순회하고 그다음에 M짜리 배열을 순회하는 것 또한 `O(N + M)`이므로 각각의 최댓값을 구해야 함.

### 1.2.2 시간 복잡도를 줄이는 법

![[Pasted image 20250823181725.png]]
> 만약 문제의 제한 시간이 1초 이내라면 N으로 유추 가능한 알고리즘을 의미함.

### 1.2.3 여러 알고리즘을 사용할 때 시간 복잡도 생각해보기
```java

int[] arr

for(int i = 0; i < arr.length; i++){
	for(int j = i + 1; j < arr.length; j++){
		int a = arr[i];
		int b = arr[j];
		
		//출력
	}
}

// n(n-1)/2 => 1/2*O(n^2) + 3/2n + 1
```

이 로직도 for문을 두 번 완전히 순회하지는 않지만 시간 복잡도는 O(n^2)임
- 시간 복잡도를 잘 따져봐야 함.







